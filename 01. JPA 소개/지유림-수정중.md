# 서론
- ORM(Object-Relational Mapping) : 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 Framework
- 

## SQL을 직접 다룰 때 발생하는 문제점
1. 반복 : DAO(데이터 접근 계층)을 개발하려면 CRUD를 위한 SQL과 JDBC API를 일일히 코드로 작성해야하고, 각 테이블마다 반복해야함
2. 진정한 의미의 계층 분할이 어려움 : 수정사항이 생기면 DAO를 열어 매번 확인해야함
3. 엔티티를 신뢰할 수 없음 : 엔티티로만으로는 확실하게 확인하기 어려움
4. SQL에 의존적인 개발을 피하기 어려움 : 결국 SQL을 확인해봐야 함

<br>

## JPA는 어떻게 해결할까?
> 개발자가 **직접** 개발하는 것이 아닌, JPA에서 제공하는 **API** 를 사용하자!
> 밑에는 약간의 예시이다.
- 저장 : `persist()`, JPA가 객체와 매핑정보를 보고 적절한 INSERT SQL을 생성 해 데이터베이스에 전달
- 조회 : `find()`, 하나의 객체를 조회함 -> SELECT SQL을 생성 해 데이터베이스에 전달
- 수정 : 별도의 메소드 제공 X
- 연관된 객체 조회 : 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행
> **개발자가 SQL을 만드는 것이 아닌 JPA가 알아서 SQL을 만들어준다!**

<br>

## 패러다임의 불일치
> 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법이 다르다. <br>
> 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다 <br>

## 패러다임의 불일치로 인해 발생하는 문제와 JPA를 통한 해결책
**예시코드**
```java
abstract calss Item {
  Long id;
  String name;
  int price;
}

class Album extends Item {
  String artist;
}

class Movie extends Item {
  String director;
  String actor;
}

class Book extends Item {
  String author;
  String isbn;
}
```

### 상속
- 객체는 `상속` 이라는 개념이 존재하지만, 테이블은 기능이 없다. (일부 지원하긴 하지만 객체의 상속과는 약간 다름)
- 테이블에서 `상속`을 구현하려면 작성해야 할 코드량이 만만치 않음.. -> **컬렉션에 보관 한다면 쉬울텐데!**

### JPA
- 자바 컬렉션에 저장하듯이 JPA에게 객체를 전달해 저장하면 된다!
```java
// 저장
jpa.persist(album); // => 두 번 INSERT를 실행, INSERT INTO ITEM... , INSERT INTO ALBUM...
```
```java
// 조회
String albumId = "id100";
Album album = jpa.find(Album.class, albumId); // 밑의 SELECT문 참고
```
```SQL
SELECT I.*, A.*
  FROM ITEM I
  JOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID
```

<br>

### 연관관계
- **객체**는 `참조`를 사용해 다른 **객체**와 연관관계를 가지고, `참조`에 접근해 연관된 **객체**를 조회함
- **테이블**은 `외래 키`를 사용해 다른 **테이블**과 연관관계를 가지고, `조인`을 사용해서 연관된 **테이블**을 조회함

**객체지향 모델링**
![image](https://github.com/user-attachments/assets/076d41c9-9a9b-4fdb-ad90-7206808e8152)

```java
class Member {
  String id;       // MEMBER_ID 컬럼 사용
  Team team;       // 참조로 연관관계 맺기
  String username; // USERNAME 컬럼 사용

  Team getTeam() {
    return team;
  }
}

class Team {
  Long id;     // TEAM_ID PK 사용
  String name' // NAME 컬럼 사용
}
```

=> 개발자가 중간역할을 하기 위해 조회, 저장... 다양한 곳에서 소모하는 비용이 커진다!


### JPA

